{"version":3,"sources":["../src/helper.js"],"names":["Style","parse","text","start","end","undefined","replace","RegExp","toString","black","red","green","yellow","blue","magenta","cyan","white","gray","bold","Log","verboseMode","welcome","console","info","message","log","Date","error","ok","done","verbose","space"],"mappings":"AAAA;;;;;;;;;AAUA;;AAGA;;;;;;;;;;AAMO,IAAMA,wBAAQ;;AAEpB;;;;;;;;;AASAC,QAAO,eAAEC,IAAF,EAAQC,KAAR,EAAgC;AAAA,MAAjBC,GAAiB;;AACtC,MAAIF,SAASG,SAAb,EAAyB;AACxB,OAAMC,UAAU,IAAIC,MAAJ,gBAA0BH,GAA1B,EAAkC,GAAlC,CAAhB,CADwB,CACiC;;AAEzD,oBAAkBD,KAAlB,GAA4BD,KAAKM,QAAL,GAAgBF,OAAhB,CAAyBA,OAAzB,YAA6CH,KAA7C,CAA5B,aAA+FC,GAA/F;AACA,GAJD,MAKK;AACJ;AACA;AACD,EApBmB;;AAsBpB;;;;;;;AAOAK,QAAO;AAAA,SAAQT,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EA7Ba;AA8BpBQ,MAAK;AAAA,SAAQV,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EA9Be;AA+BpBS,QAAO;AAAA,SAAQX,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EA/Ba;AAgCpBU,SAAQ;AAAA,SAAQZ,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EAhCY;AAiCpBW,OAAM;AAAA,SAAQb,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EAjCc;AAkCpBY,UAAS;AAAA,SAAQd,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EAlCW;AAmCpBa,OAAM;AAAA,SAAQf,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EAnCc;AAoCpBc,QAAO;AAAA,SAAQhB,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EApCa;AAqCpBe,OAAM;AAAA,SAAQjB,MAAMC,KAAN,CAAaC,IAAb,QAAR;AAAA,EArCc;AAsCpBgB,OAAM;AAAA,SAAQlB,MAAMC,KAAN,CAAaC,IAAb,cAAR;AAAA;;AAtCc,CAAd;;AA2CP;;;;;AAKO,IAAMiB,oBAAM;AAClBC,cAAa,KADK,EACE;;AAEpB;;;;;AAKAC,UAAS,iBAAEnB,IAAF,EAAY;AACpBoB,UAAQC,IAAR,mDAAgCvB,MAAMkB,IAAN,MAAehB,IAAf,CAAhC;AACA,EAViB;;AAYlB;;;;;AAKAsB,UAAS,iBAAEtB,IAAF,EAAY;AACpBoB,UAAQG,GAAR,CAAiB,IAAIC,IAAJ,GAAWlB,QAAX,EAAjB,WAA8CN,IAA9C;AACA,EAnBiB;;AAqBlB;;;;;AAKAyB,QAAO,eAAEzB,IAAF,EAAY;AAClBoB,UAAQK,KAAR,wCAAgC3B,MAAMU,GAAN,eAAuBR,IAAvB,CAAhC;AACA,EA5BiB;;AA8BlB;;;;;AAKAqB,OAAM,cAAErB,IAAF,EAAY;AACjBoB,UAAQC,IAAR,iDAAwCrB,IAAxC;AACA,EArCiB;;AAuClB;;;;;AAKA0B,KAAI,YAAE1B,IAAF,EAAY;AACfoB,UAAQC,IAAR,kCAA8BvB,MAAMW,KAAN,eAAyBT,IAAzB,CAA9B;AACA,EA9CiB;;AAgDlB;;;;;AAKA2B,OAAM,cAAE3B,IAAF,EAAY;AACjBoB,UAAQC,IAAR,wCAA+BvB,MAAMW,KAAN,CAAaX,MAAMkB,IAAN,CAAYhB,IAAZ,CAAb,CAA/B;AACA,EAvDiB;;AAyDlB;;;;;AAKA4B,UAAS,iBAAE5B,IAAF,EAAY;AACpB,MAAIiB,IAAIC,WAAR,EAAsB;AACrBE,WAAQC,IAAR,wCAA+BvB,MAAMiB,IAAN,eAAwBf,IAAxB,CAA/B;AACA;AACD,EAlEiB;;AAoElB;;;AAGA6B,QAAO,iBAAM;AACZT,UAAQG,GAAR;AACA;AAzEiB,CAAZ","file":"helper.js","sourcesContent":["/***************************************************************************************************************************************************************\n *\n * Helper functions for use across the system\n *\n * Style - Returning ansi escape color codes\n * Log   - A logging object for logging prettiness\n *\n **************************************************************************************************************************************************************/\n\n\n'use strict';\n\n\n/**\n * Style - Returning ansi escape color codes\n * Credit to: https://github.com/chalk/ansi-styles\n *\n * @type {Object}\n */\nexport const Style = {\n\n\t/**\n\t * Parse ansi code while making sure we can nest colors\n\t *\n\t * @param  {string} text  - The text to be enclosed with an ansi escape string\n\t * @param  {string} start - The color start code, defaults to the standard color reset code 39m\n\t * @param  {string} end   - The color end code\n\t *\n\t * @return {string}       - The escaped text\n\t */\n\tparse: ( text, start, end = `39m` ) => {\n\t\tif( text !== undefined ) {\n\t\t\tconst replace = new RegExp( `\\\\u001b\\\\[${ end }`, 'g' ); // find any resets so we can nest styles\n\n\t\t\treturn `\\u001B[${ start }${ text.toString().replace( replace, `\\u001B[${ start }` ) }\\u001b[${ end }`;\n\t\t}\n\t\telse {\n\t\t\treturn ``;\n\t\t}\n\t},\n\n\t/**\n\t * Style a string with ansi escape codes\n\t *\n\t * @param  {string} text - The string to be wrapped\n\t *\n\t * @return {string}      - The string with opening and closing ansi escape color codes\n\t */\n\tblack: text => Style.parse( text, `30m` ),\n\tred: text => Style.parse( text, `31m` ),\n\tgreen: text => Style.parse( text, `32m` ),\n\tyellow: text => Style.parse( text, `33m` ),\n\tblue: text => Style.parse( text, `34m` ),\n\tmagenta: text => Style.parse( text, `35m` ),\n\tcyan: text => Style.parse( text, `36m` ),\n\twhite: text => Style.parse( text, `37m` ),\n\tgray: text => Style.parse( text, `90m` ),\n\tbold: text => Style.parse( text, `1m`, `22m` ),\n\n};\n\n\n/**\n * A logging object for logging prettiness\n *\n * @type {Object}\n */\nexport const Log = {\n\tverboseMode: false, // verbose flag\n\n\t/**\n\t * Log a welcome message\n\t *\n\t * @param  {string} text - The text you want to log\n\t */\n\twelcome: ( text ) => {\n\t\tconsole.info(` ðŸ¦ðŸ¦ðŸ¦        ${ Style.bold(`${ text }`) }`);\n\t},\n\n\t/**\n\t * Log a message\n\t *\n\t * @param  {string}  text - The text you want to log\n\t */\n\tmessage: ( text ) => {\n\t\tconsole.log( `${ new Date().toString() } : ${ text }`);\n\t},\n\n\t/**\n\t * Log an error\n\t *\n\t * @param  {string} text - The text you want to log with the error\n\t */\n\terror: ( text ) => {\n\t\tconsole.error(` ðŸ¦ ðŸ¦        ${ Style.red(`ERROR:   ${ text }`) }`);\n\t},\n\n\t/**\n\t * Log some information\n\t *\n\t * @param  {string}  text - The text you want to log\n\t */\n\tinfo: ( text ) => {\n\t\tconsole.info(` ðŸ”” ðŸ¦        INFO:    ${ text }`);\n\t},\n\n\t/**\n\t * Log success\n\t *\n\t * @param  {string}  text - The text you want to log\n\t */\n\tok: ( text ) => {\n\t\tconsole.info(` âœ” ðŸ¦        ${ Style.green(`OK:      ${ text }`) }`);\n\t},\n\n\t/**\n\t * Log the final message\n\t *\n\t * @param  {string}  text - The text you want to log\n\t */\n\tdone: ( text ) => {\n\t\tconsole.info(` ðŸš€ ðŸ¦        ${ Style.green( Style.bold( text ) ) }`);\n\t},\n\n\t/**\n\t * Log a verbose message\n\t *\n\t * @param  {string}  text - The text you want to log\n\t */\n\tverbose: ( text ) => {\n\t\tif( Log.verboseMode ) {\n\t\t\tconsole.info(` ðŸ™Š ðŸ¦        ${ Style.gray(`VERBOSE: ${ text }`) }`);\n\t\t}\n\t},\n\n\t/**\n\t * Add some space to the output\n\t */\n\tspace: () => {\n\t\tconsole.log(`\\n`);\n\t},\n};\n"]}